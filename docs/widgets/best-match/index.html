<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Best Matching Algorithm Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError: false
            });
        });
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        /* --- SMOOTHNESS & PERFORMANCE ENHANCEMENTS --- */
        html {
            scroll-behavior: smooth;
        }

        /* --- Neumorphic Theme Variables --- */
        :root {
            --bg-color: #f8fafc; /* Keep original light background */
            --light-shadow: rgba(255, 255, 255, 1);
            --dark-shadow: rgba(148, 163, 184, 0.3); /* Subtle slate shadows */
            --ease-out-quad: cubic-bezier(0.25, 0.46, 0.45, 0.94);
            --ease-out-cubic: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            transition: background 1.5s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        /* --- Neumorphic Page Container --- */
        .neumorphic-page-container {
            background: var(--bg-color);
            border-radius: 25px;
            box-shadow: 0 0 24px var(--dark-shadow);
            margin: 1rem;
            padding: 2rem;
            min-height: calc(100vh - 2rem);
            position: relative;
            overflow: hidden;
        }
        
        .neumorphic-content {
            position: relative;
            z-index: 1;
        }

        /* --- Neumorphic Card Styles --- */
        .interactive-card {
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            box-shadow: 8px 8px 16px var(--dark-shadow), -8px -8px 16px var(--light-shadow);
            transition: transform 0.35s var(--ease-out-cubic),
                        box-shadow 0.35s var(--ease-out-cubic),
                        border-color 0.35s var(--ease-out-cubic);
            will-change: transform, box-shadow;
        }
        .interactive-card:hover {
            box-shadow: 12px 12px 24px var(--dark-shadow), -12px -12px 24px var(--light-shadow);
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .demo-card { 
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.75) 0%, rgba(248, 250, 252, 0.65) 100%); 
            border-color: rgba(226, 232, 240, 0.8);
            border-left: 3px solid #0d9488;
            border-radius: 20px;
            box-shadow: 8px 8px 16px var(--dark-shadow), -8px -8px 16px var(--light-shadow), 0 2px 8px rgba(0, 0, 0, 0.06), 0 1px 3px rgba(0, 0, 0, 0.04);
        }
        
        .intro-card { 
            background: linear-gradient(135deg, rgba(254, 252, 232, 0.6) 0%, rgba(254, 243, 199, 0.5) 100%); 
            border-color: rgba(251, 191, 36, 0.5);
            border-radius: 20px;
            box-shadow: 8px 8px 16px var(--dark-shadow), -8px -8px 16px var(--light-shadow);
        }
        .solution-card { background: linear-gradient(135deg, rgba(236, 253, 245, 0.6) 0%, rgba(209, 250, 229, 0.5) 100%); border-color: rgba(110, 231, 183, 0.6); }
        .formula-card { background: linear-gradient(135deg, rgba(237, 233, 254, 0.6) 0%, rgba(221, 214, 254, 0.5) 100%); border-color: rgba(196, 181, 253, 0.6); }

        /* --- Chart & Visualization Elements --- */
        .axis-label { position: absolute; font-size: 0.75rem; color: #475569; font-weight: 500; white-space: nowrap; z-index: 6; }
        .ideal-mapping-window { 
            position: absolute; 
            border: 2px solid #0d9488; 
            background-color: rgba(20, 184, 166, 0.1); 
            box-sizing: border-box; 
            z-index: 1; 
            transition: left 0.4s var(--ease-out-cubic), bottom 0.4s var(--ease-out-cubic), width 0.4s var(--ease-out-cubic), height 0.4s var(--ease-out-cubic), background-color 0.25s var(--ease-out-cubic), border-color 0.25s var(--ease-out-cubic), box-shadow 0.25s var(--ease-out-cubic); 
            pointer-events: none; 
            border-radius: 0.375rem;
            box-shadow: 
                0 0 8px rgba(13, 148, 136, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        .best-match-cell { 
            position: absolute; 
            background-color: rgba(245, 158, 11, 0.3); 
            border: 2px solid #f59e0b; 
            box-sizing: border-box; 
            z-index: 3; 
            transition: left 0.4s var(--ease-out-cubic), bottom 0.4s var(--ease-out-cubic), width 0.4s var(--ease-out-cubic), height 0.4s var(--ease-out-cubic), background-color 0.25s var(--ease-out-cubic), border-color 0.25s var(--ease-out-cubic), box-shadow 0.25s var(--ease-out-cubic), opacity 0.25s var(--ease-out-cubic); 
            pointer-events: none; 
            border-radius: 0.375rem;
            box-shadow: 
                0 0 8px rgba(245, 158, 11, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        .max-similarity-cell-highlight { 
            position: absolute; 
            background-color: rgba(139, 92, 246, 0.25); 
            border: 2px solid #8b5cf6; 
            box-sizing: border-box; 
            z-index: 2; 
            transition: left 0.4s var(--ease-out-cubic), bottom 0.4s var(--ease-out-cubic), width 0.4s var(--ease-out-cubic), height 0.4s var(--ease-out-cubic), background-color 0.25s var(--ease-out-cubic), border-color 0.25s var(--ease-out-cubic), box-shadow 0.25s var(--ease-out-cubic), opacity 0.25s var(--ease-out-cubic); 
            pointer-events: none; 
            display: flex; 
            align-items: flex-end; 
            justify-content: flex-end; 
            padding: 2px; 
            border-radius: 0.375rem;
            box-shadow: 
                0 0 8px rgba(139, 92, 246, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        .context-window-text { font-size: 0.6rem; color: white; background-color: rgba(0, 0, 0, 0.5); padding: 1px 3px; border-radius: 2px; white-space: nowrap; pointer-events: none; }
        .context-visualization-toggle { 
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(139, 92, 246, 0.9);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
            z-index: 10;
        }
        .context-visualization-toggle:hover { 
            background: rgba(139, 92, 246, 1);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
            border-color: rgba(255, 255, 255, 0.3);
        }
        .context-visualization-toggle.active { 
            background: rgba(5, 150, 105, 0.9);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.3);
        }
        .context-visualization-toggle.active:hover { 
            background: rgba(5, 150, 105, 1);
            box-shadow: 0 4px 12px rgba(5, 150, 105, 0.4);
        }
        .context-candidate-highlight { 
            position: absolute; 
            background-color: rgba(139, 92, 246, 0.15); 
            border: 1px dashed #8b5cf6; 
            box-sizing: border-box; 
            z-index: 4; 
            pointer-events: none; 
            border-radius: 0.25rem;
            opacity: 0;
            transition: left 0.4s var(--ease-out-cubic), bottom 0.4s var(--ease-out-cubic), width 0.4s var(--ease-out-cubic), height 0.4s var(--ease-out-cubic), opacity 0.25s var(--ease-out-cubic), background-color 0.25s var(--ease-out-cubic), border-color 0.25s var(--ease-out-cubic);
        }
        .context-candidate-highlight.visible { 
            opacity: 1; 
        }
        .similarity-value-cell-container { position: absolute; display: flex; align-items: center; justify-content: center; box-sizing: border-box; z-index: 4; }
        .similarity-input-cell { width: 100%; height: 100%; text-align: center; border: none; background-color: transparent; font-size: 0.7rem; color: #475569; box-sizing: border-box; border-radius: 4px; padding: 2px; }
        .similarity-input-cell:focus { outline: 1px solid #3b82f6; background-color: rgba(255, 255, 255, 0.9); }
                .chart-grid-background {
            background-color: #fafbfc;
            border-radius: 15px;
            box-shadow: inset 5px 5px 10px var(--dark-shadow), inset -5px -5px 10px var(--light-shadow), inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        /* --- Neumorphic Input & Button Styles --- */
        .neumorphic-input {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            box-shadow: inset 4px 4px 8px var(--dark-shadow), inset -4px -4px 8px var(--light-shadow);
            transition: box-shadow 0.3s var(--ease-out-quad), border-color 0.3s var(--ease-out-quad);
            color: #374151;
        }
        .neumorphic-input:focus {
            outline: none;
            box-shadow: inset 6px 6px 12px var(--dark-shadow), inset -6px -6px 12px var(--light-shadow);
            border-color: #0d9488;
        }

        .neumorphic-btn {
            border-radius: 12px;
            background: linear-gradient(135deg, #0d9488 0%, #14b8a6 100%);
            color: white;
            font-weight: 600;
            box-shadow: 5px 5px 10px var(--dark-shadow), -5px -5px 10px var(--light-shadow);
            transition: all 0.2s var(--ease-out-quad);
            border: none;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .neumorphic-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        .neumorphic-btn:hover {
            box-shadow: 6px 6px 12px var(--dark-shadow), -6px -6px 12px var(--light-shadow);
            transform: translateY(-1px) scale(1.02);
        }
        .neumorphic-btn:hover::before {
            left: 100%;
        }
        .neumorphic-btn:active {
            box-shadow: inset 4px 4px 8px var(--dark-shadow), inset -4px -4px 8px var(--light-shadow);
            transform: translateY(1px);
        }
        .neumorphic-btn.primary {
            background: linear-gradient(135deg, #0d9488 0%, #14b8a6 100%);
        }
        
        /* --- Tour Styles --- */
        #tour-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9998; opacity: 0; transition: opacity 0.4s ease-in-out; pointer-events: none; }
        .tour-highlight { position: relative; z-index: 9999; box-shadow: 0 0 0 9999px rgba(0,0,0,0.6), 0 0 20px rgba(255, 255, 255, 0.9); border-radius: 0.5rem; transition: box-shadow 0.4s ease-in-out; }
        #tour-callout { 
            position: absolute; 
            background: rgba(255, 255, 255, 0.95); 
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: #334155; 
            padding: 1.25rem; 
            border-radius: 20px; 
            box-shadow: 8px 8px 16px var(--dark-shadow), -8px -8px 16px var(--light-shadow);
            z-index: 10000; 
            max-width: 320px; 
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: opacity 0.3s var(--ease-out-cubic), transform 0.3s var(--ease-out-cubic); 
            transform: translateY(10px); 
            opacity: 0; 
        }
        #tour-callout.visible { transform: translateY(0); opacity: 1; }
        #tour-callout button { 
            background: linear-gradient(135deg, #0d9488 0%, #14b8a6 100%); 
            color: white; 
            padding: 0.5rem 1rem; 
            border: none; 
            border-radius: 12px; 
            cursor: pointer; 
            font-weight: 600;
            box-shadow: 4px 4px 8px var(--dark-shadow), -4px -4px 8px var(--light-shadow);
            transition: all 0.2s var(--ease-out-quad);
        }
        #tour-callout button:hover { 
            box-shadow: 6px 6px 12px var(--dark-shadow), -6px -6px 12px var(--light-shadow);
            transform: translateY(-1px) scale(1.02); 
        }

        /* --- Other Styled Components --- */
        .preset-btn { 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, #0d9488 0%, #14b8a6 100%);
            position: relative;
            overflow: hidden;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }
        .preset-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        .preset-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 12px 24px rgba(6, 78, 59, 0.4),
                0 4px 8px rgba(255, 255, 255, 0.3) inset;
        }
        .preset-btn:hover::before {
            left: 100%;
        }
        .preset-btn:hover i {
            transform: scale(1.1);
        }
        .preset-btn i {
            transition: all 0.3s ease;
        }

        /* --- Hero Section Styles --- */
        #hero-section {
            background: linear-gradient(45deg, #0d9488, #0f766e); 
            color: white; 
        }
        #hero-section h1 {
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2); 
        }

        /* --- Hero Tour Button (No White Glow) --- */
        .hero-tour-btn {
            background: linear-gradient(135deg, #0f766e 0%, #064e3b 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.75rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .hero-tour-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
            transition: left 0.5s ease;
        }

        .hero-tour-btn:hover {
            background: linear-gradient(135deg, #14b8a6 0%, #0f766e 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .hero-tour-btn:hover::before {
            left: 100%;
        }

        .hero-tour-btn:active {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
        }

        details summary { cursor: pointer; user-select: none; transition: color 0.2s var(--ease-out-quad); }
        details summary:hover { color: #1d4ed8; }
        details summary::-webkit-details-marker { display: none; }
        details summary .summary-icon { display: inline-block; margin-right: 0.5rem; transition: transform 0.25s var(--ease-out-cubic); }
        details[open] summary .summary-icon { transform: rotate(90deg); }
        .step-number { 
            width: 2rem; height: 2rem; 
            border-radius: 50%; 
            display: flex; align-items: center; justify-content: center; 
            color: white; font-weight: bold; font-size: 0.875rem; 
            flex-shrink: 0; 
        }
        
        /* Math container styling */
        .math-container {
            background: #dbeafe;
            border: 1px solid #93c5fd;
            border-radius: 0.75rem;
            padding: 0.75rem;
            margin-top: 0.75rem;
            margin-left: -0.75rem;
            margin-right: -0.75rem;
            text-align: left;
        }
        
        /* KaTeX color overrides */
        .katex {
            color: #1e40af !important;
        }
        
        .katex .mord,
        .katex .mop,
        .katex .mbin,
        .katex .mrel,
        .katex .mopen,
        .katex .mclose,
        .katex .mpunct {
            color: #1e40af !important;
        }
        
        .katex .mtext {
            color: #1e3a8a !important;
        }
        .math-formula { 
            background: linear-gradient(135deg, rgba(248, 250, 252, 0.8) 0%, rgba(241, 245, 249, 0.9) 100%); 
            border: 1px solid rgba(203, 213, 225, 0.5); 
        }

        /* --- Testing Assistant Styles --- */

        .testing-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.7) 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s var(--ease-out-cubic);
        }
        .testing-modal.visible {
            opacity: 1;
            visibility: visible;
        }
        .testing-modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            padding: 2.5rem;
            max-width: 90vw;
            max-height: 85vh;
            width: 700px;
            box-shadow: 
                12px 12px 24px var(--dark-shadow), 
                -12px -12px 24px var(--light-shadow),
                0 8px 32px rgba(0, 0, 0, 0.1);
            transform: translateY(30px) scale(0.9);
            transition: all 0.5s var(--ease-out-cubic);
            overflow-y: auto;
            box-sizing: border-box;
            position: relative;
        }
        /* Custom scrollbar for testing modal */
        .testing-modal-content::-webkit-scrollbar {
            width: 8px;
        }
        .testing-modal-content::-webkit-scrollbar-track {
            background: rgba(248, 250, 252, 0.3);
            border-radius: 1rem;
        }
        .testing-modal-content::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(13, 148, 136, 0.6) 0%, rgba(20, 184, 166, 0.4) 100%);
            border-radius: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .testing-modal-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(13, 148, 136, 0.8) 0%, rgba(20, 184, 166, 0.6) 100%);
        }
        /* Firefox scrollbar styling */
        .testing-modal-content {
            scrollbar-width: thin;
            scrollbar-color: rgba(13, 148, 136, 0.6) rgba(248, 250, 252, 0.3);
        }
        .testing-modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent 0%, rgba(13, 148, 136, 0.8) 50%, transparent 100%);
        }
        .testing-modal.visible .testing-modal-content {
            transform: translateY(0) scale(1) rotateX(0deg);
        }
        .testing-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 2px solid rgba(226, 232, 240, 0.6);
            position: relative;
        }
        .testing-modal-header::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 60px;
            height: 2px;
            background: linear-gradient(90deg, #0d9488 0%, #14b8a6 100%);
            border-radius: 1px;
        }
        .testing-modal-close {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            color: #64748b;
            padding: 0.75rem;
            border-radius: 50%;
            box-shadow: 4px 4px 8px var(--dark-shadow), -4px -4px 8px var(--light-shadow);
            transition: all 0.3s var(--ease-out-cubic);
            width: 3rem;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .testing-modal-close:hover {
            color: #0d9488;
            transform: rotate(90deg) scale(1.1);
            box-shadow: 6px 6px 12px var(--dark-shadow), -6px -6px 12px var(--light-shadow);
        }
        .test-category {
            margin-bottom: 2rem;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            box-shadow: 6px 6px 12px var(--dark-shadow), -6px -6px 12px var(--light-shadow);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        .test-category::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(20, 184, 166, 0.05) 0%, rgba(15, 118, 110, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .test-category:hover::before {
            opacity: 1;
        }
        .test-category:hover {
            transform: translateY(-2px);
            box-shadow: 8px 8px 16px var(--dark-shadow), -8px -8px 16px var(--light-shadow);
        }
        .test-category h3 {
            color: #0f172a;
            margin-bottom: 1.5rem;
            font-size: 1.25rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            letter-spacing: -0.025em;
        }
        .test-category h3 i {
            margin-right: 0.75rem;
            color: #0d9488;
            background: linear-gradient(135deg, #e6fffa 0%, #b2f5ea 100%);
            padding: 0.5rem;
            border-radius: 50%;
            font-size: 1rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
        }
        .test-category:hover h3 i {
            transform: translateY(-2px) scale(1.1);
            box-shadow: 
                0 8px 16px rgba(20, 184, 166, 0.3),
                0 4px 8px rgba(255, 255, 255, 0.9) inset;
            color: #0f766e;
        }
        .test-item {
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 4px 4px 8px var(--dark-shadow), -4px -4px 8px var(--light-shadow);
            transition: all 0.2s var(--ease-out-quad);
        }
        .test-item:hover {
            transform: translateY(-1px);
            box-shadow: 6px 6px 12px var(--dark-shadow), -6px -6px 12px var(--light-shadow);
        }
        .test-item:last-child {
            margin-bottom: 0;
        }
        .test-item h4 {
            color: #1e293b;
            margin-bottom: 0.75rem;
            font-size: 1rem;
            font-weight: 600;
            letter-spacing: -0.025em;
        }
        .test-item p {
            color: #475569;
            font-size: 0.875rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }
        .test-checklist {
            list-style: none;
            padding: 0;
            margin: 0;
            background: rgba(248, 250, 252, 0.4);
            border-radius: 0.5rem;
            padding: 1rem;
            border: 1px solid rgba(226, 232, 240, 0.4);
        }
        .test-checklist li {
            margin-bottom: 0.75rem;
            display: flex;
            align-items: flex-start;
            font-size: 0.875rem;
            color: #334155;
            line-height: 1.5;
            transition: all 0.2s var(--ease-out-quad);
        }
        .test-checklist li:last-child {
            margin-bottom: 0;
        }
        .test-checklist li:hover {
            color: #0d9488;
            transform: translateX(2px);
        }
        .test-checklist li::before {
            content: "✓";
            margin-right: 0.75rem;
            color: #0d9488;
            font-weight: bold;
            background: rgba(13, 148, 136, 0.1);
            border-radius: 50%;
            width: 1.25rem;
            height: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            flex-shrink: 0;
            margin-top: 0.125rem;
        }
    </style>
</head>
<body class="h-full text-slate-700 antialiased">
    <div id="app-background" class="fixed inset-0 z-[-1] transition-all duration-1000"></div>
    <div id="tour-overlay"></div>

    <!-- Neumorphic Page Container -->
    <div class="neumorphic-page-container">
        <div class="neumorphic-content">
            <article class="interactive-card overflow-hidden">
                <!-- Hero Section -->
                <section id="hero-section" class="py-6 px-4 sm:px-6 lg:px-8 relative">
                    <div class="container mx-auto">
                        <!-- Start Tour Button - Top Right -->
                        <button id="start-tour-btn" class="hero-tour-btn absolute top-4 right-4 py-2 px-4">
                            <i class="fas fa-magic mr-2"></i>Start Tour
                        </button>
                        
                        <div class="text-left max-w-4xl">
                            <div class="flex items-center justify-start mb-4">
                                <div class="bg-teal-200 text-teal-800 px-3 py-1 rounded-full text-xs font-semibold uppercase tracking-wide mr-2">Interactive Demo</div>
                                <div class="bg-white bg-opacity-20 text-white px-3 py-1 rounded-full text-xs font-semibold">Core VCS Component</div>
                            </div>
                            <h1 class="text-3xl sm:text-4xl lg:text-5xl font-extrabold text-white mb-3 leading-tight">
                                Best Matching Algorithm
                            </h1>
                            <p class="text-teal-200 text-base sm:text-lg mb-6 max-w-3xl">
                                Explore how the best matching algorithm solves semantic ambiguity and collision problems to find optimal chunk alignments in the Video Comprehension Score framework.
                            </p>
                        </div>
                    </div>
                </section>

                <!-- Main Container -->
                <main class="w-full max-w-8xl mx-auto p-6">

        <!-- Introduction Section -->
        <div id="tour-step-intro" class="intro-card interactive-card rounded-xl p-6 mb-8">
            <div class="flex items-center mb-4"><i class="fas fa-lightbulb text-amber-600 text-xl mr-3"></i><h2 class="text-xl font-semibold text-amber-800">Introduction to Best Matching</h2></div>
            
            <!-- Definition -->
            <div class="bg-white bg-opacity-70 p-4 rounded-lg mb-6 border-l-4 border-amber-500">
                <p class="text-sm text-slate-700 mb-3"><strong>What is the Best Matching Problem?</strong> When comparing two texts, chunks often exhibit high similarity with multiple candidates, creating semantic ambiguity and collisions. The Best Matching algorithm solves this by using adaptive context windows and mapping window constraints to find optimal one-to-one alignments that respect narrative structure.</p>
                
                <!-- Warning -->
                <div class="bg-orange-50 border border-orange-200 rounded-xl p-3 mt-3">
                    <div class="flex items-start">
                        <i class="fas fa-exclamation-triangle text-orange-500 mr-2 mt-0.5"></i>
                        <div>
                            <p class="text-xs text-orange-800 font-medium mb-1">⚠️ Prerequisites Required</p>
                            <p class="text-xs text-orange-700">Please read the VCS research paper and understand the theoretical foundation of semantic matching before using this interactive demo. This visualization assumes familiarity with the underlying concepts.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Additional Prerequisites -->
                <div class="bg-blue-50 border border-blue-200 rounded-xl p-3 mt-3">
                    <div class="flex items-start">
                        <i class="fas fa-info-circle text-blue-500 mr-2 mt-0.5"></i>
                        <div>
                            <p class="text-xs text-blue-800 font-medium mb-1">📚 Additional Prerequisites</p>
                            <p class="text-xs text-blue-700">Before exploring Best Matching, we recommend visiting the <a href="../mapping-window/" class="font-bold underline hover:text-blue-900">Mapping Window Demo</a> to understand how mapping windows work. Best Matching relies on mapping window constraints to find optimal alignments while respecting narrative structure.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <!-- Left Column: Definitions -->
                <div class="space-y-6">
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg">
                        <h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-sitemap text-red-500 mr-2"></i>Semantic Collisions</h3>
                        <p class="text-sm text-slate-700">A chunk exhibits high similarity with multiple chunks from the other text, resulting in many-to-one matches rather than desired one-to-one correspondences.</p>
                    </div>
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg">
                        <h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-question-circle text-amber-500 mr-2"></i>Semantic Ambiguity</h3>
                        <p class="text-sm text-slate-700">A generated chunk superficially matches a reference chunk due to lexical overlap, despite another reference chunk being a more suitable narrative counterpart.</p>
                    </div>
                </div>
                <!-- Right Column: Example Table and Elaboration -->
                <div class="bg-white bg-opacity-60 p-4 rounded-lg">
                    <h4 class="font-semibold text-slate-800 mb-3 text-center">Illustrative Similarity Scenario</h4>
                    <div class="overflow-x-auto">
                        <table class="mx-auto text-sm w-full">
                            <thead>
                                <tr class="border-b-2 border-slate-300">
                                    <th class="px-4 py-2"></th>
                                    <th class="px-4 py-2 font-semibold">Ref 1</th>
                                    <th class="px-4 py-2 font-semibold">Ref 5</th>
                                    <th class="px-4 py-2 font-semibold">Ref 9</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="border-b border-slate-200">
                                    <td class="px-4 py-2 font-semibold">Gen 1</td>
                                    <td class="px-4 py-2 text-center bg-red-100 font-bold">0.80</td>
                                    <td class="px-4 py-2 text-center">0.32</td>
                                    <td class="px-4 py-2 text-center bg-red-100 font-bold">0.78</td>
                                </tr>
                                <tr class="border-b border-slate-200">
                                    <td class="px-4 py-2 font-semibold">Gen 6</td>
                                    <td class="px-4 py-2 text-center">0.30</td>
                                    <td class="px-4 py-2 text-center bg-green-100 font-bold">0.85</td>
                                    <td class="px-4 py-2 text-center">0.25</td>
                                </tr>
                                <tr>
                                    <td class="px-4 py-2 font-semibold">Gen 10</td>
                                    <td class="px-4 py-2 text-center bg-red-100 font-bold">0.80</td>
                                    <td class="px-4 py-2 text-center">0.28</td>
                                    <td class="px-4 py-2 text-center bg-red-100 font-bold">0.79</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="mt-4 text-xs text-slate-600 space-y-2">
                        <p><strong class="text-red-600">Collision:</strong> Both <code class="bg-slate-200 px-1 rounded">Gen 1</code> and <code class="bg-slate-200 px-1 rounded">Gen 10</code> have a high similarity of <code class="bg-slate-200 px-1 rounded">0.80</code> with <code class="bg-slate-200 px-1 rounded">Ref 1</code>. A naive algorithm would struggle to choose the correct one-to-one match.</p>
                        <p><strong class="text-red-600">Ambiguity:</strong> <code class="bg-slate-200 px-1 rounded">Gen 10</code> has a high score with <code class="bg-slate-200 px-1 rounded">Ref 1</code> (<code class="bg-slate-200 px-1 rounded">0.80</code>) due to word overlap, but its true narrative match is <code class="bg-slate-200 px-1 rounded">Ref 9</code> (<code class="bg-slate-200 px-1 rounded">0.79</code>). The algorithm must look beyond the max score.</p>
                         <p><strong class="text-green-600">Clear Match:</strong> In contrast, <code class="bg-slate-200 px-1 rounded">Gen 6</code> has a clear, unambiguous best match with <code class="bg-slate-200 px-1 rounded">Ref 5</code> (<code class="bg-slate-200 px-1 rounded">0.85</code>), which the algorithm should easily identify.</p>
                    </div>
                </div>
            </div>
             <details id="tour-step-math" class="mb-4">
                <summary class="font-semibold text-amber-700 mb-3 flex items-center"><i class="fas fa-chevron-right summary-icon"></i>Best Matching Algorithm</summary>
                <div class="mt-4 space-y-4">
                    <!-- Main Algorithm Overview -->
                    <div class="bg-white bg-opacity-70 p-4 rounded-lg border-l-4 border-amber-500">
                        <p class="text-sm text-slate-700 mb-3"><strong>Algorithm Overview:</strong> The best matching algorithm follows 7 steps to find optimal chunk alignments. The process can start with either precision or recall best matches - let's demonstrate with recall best matches using recall mapping windows for disambiguation:</p>
                        
                        <!-- Step 1: Text Embedding and Similarity Matrix Construction -->
                        <div class="bg-orange-50 border border-orange-200 rounded-xl p-3 mt-3">
                            <div class="flex items-start">
                                <i class="fas fa-layer-group text-orange-500 mr-2 mt-0.5"></i>
                                <div>
                                    <p class="text-xs text-orange-800 font-medium mb-1">Step 1: Text Embedding and Similarity Matrix Construction</p>
                                    <p class="text-xs text-orange-700 mb-2">Reference and generated chunks from the SAT (Segment Any Text) model are converted to embeddings using nv-embed-v2, and the cosine similarity matrix is computed between all chunk pairs.</p>
                                    <div class="math-container">
                                        <p class="text-xs">$E_{ref} = \text{nv-embed-v2}(C_{ref})$ where $C_{ref} = \text{SAT}(T_{ref})$</p>
                                        <p class="text-xs">$E_{gen} = \text{nv-embed-v2}(C_{gen})$ where $C_{gen} = \text{SAT}(T_{gen})$</p>
                                        <p class="text-xs">$S_{i,j} = \text{cosine\_similarity}(E_{ref,i}, E_{gen,j})$</p>
                                    </div>
                                    <p class="text-xs text-orange-700 mt-2">where $S$ is the similarity matrix with dimensions $|C_{ref}| \times |C_{gen}|$ containing cosine similarities between all chunk pairs.</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Step 2: Maximum Similarity Detection -->
                        <div class="bg-orange-50 border border-orange-200 rounded-xl p-3 mt-3">
                            <div class="flex items-start">
                                <i class="fas fa-search text-orange-500 mr-2 mt-0.5"></i>
                                <div>
                                    <p class="text-xs text-orange-800 font-medium mb-1">Step 2: Maximum Similarity Detection for Recall Best Matches</p>
                                    <p class="text-xs text-orange-700 mb-2">For each reference chunk embedding in the similarity matrix, the highest similarity score and its index are identified. This establishes the baseline for finding the best match for each reference chunk.</p>
                                    <div class="math-container">
                                        <p class="text-xs">$\text{max\_val} = \max(\text{similarity\_array})$</p>
                                        <p class="text-xs">$\text{max\_idx} = \underset{}{\arg\max}(\text{similarity\_array})$</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Step 3: Adaptive Context Window Calculation -->
                        <div class="bg-orange-50 border border-orange-200 rounded-xl p-3 mt-3">
                            <div class="flex items-start">
                                <i class="fas fa-window-maximize text-orange-500 mr-2 mt-0.5"></i>
                                <div>
                                    <p class="text-xs text-orange-800 font-medium mb-1">Step 3: Adaptive Context Window Calculation</p>
                                    <p class="text-xs text-orange-700 mb-2">An adaptive context window is calculated proportionally to the highest similarity score from Step 2. Higher maximum similarities create wider context windows for exploring more candidates, while lower similarities produce narrower windows for focused selection. Adaptive context is only applied when the highest similarity exceeds the context cutoff threshold.</p>
                                    <div class="math-container">
                                        <p class="text-xs">$\text{context\_range} = 1 - \text{context\_cutoff}$</p>
                                        <p class="text-xs">$\text{context\_window} = \frac{(\text{context\_range} - (1 - \text{max\_val})) / \text{max\_val}}{\text{context\_window\_ctrl}}$</p>
                                        <p class="text-xs">$\text{context\_threshold} = \text{max\_val} - \text{context\_window}$</p>
                                    </div>
                                    <p class="text-xs text-orange-700 mt-2">For example, a perfect similarity of 1.0 creates a context window of ~0.1, while a similarity of 0.7 produces a narrower window of ~0.035. The $\text{context\_cutoff}$ (default: 0.6) establishes the minimum similarity threshold - scores below this receive no adaptive context. The $\text{context\_window\_ctrl}$ (default: 4.0) controls the breadth of exploration around any similarity value that exceeds the context cutoff threshold.</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Step 4: Candidate Filtering -->
                        <div class="bg-orange-50 border border-orange-200 rounded-xl p-3 mt-3">
                            <div class="flex items-start">
                                <i class="fas fa-filter text-orange-500 mr-2 mt-0.5"></i>
                                <div>
                                    <p class="text-xs text-orange-800 font-medium mb-1">Step 4: Candidate Filtering</p>
                                    <p class="text-xs text-orange-700 mb-2">All similarity scores that are above or equal to the adaptive context threshold are identified as candidates. This filtering captures matches with similarity values close enough to the highest similarity, ensuring we consider alternatives that are nearly as good as the peak match.</p>
                                    <div class="math-container">
                                        <p class="text-xs">$C = \{i \mid \text{similarity\_array}_i \geq \text{context\_threshold}\}$</p>
                                        <p class="text-xs">$\text{candidates} = \text{indices where } s_i \geq \text{context\_threshold}$</p>
                                    </div>
                                    <p class="text-xs text-orange-700 mt-2">By selecting values between the context threshold and highest similarity, we obtain candidates that share comparable semantic strength, enabling position-based disambiguation in the next step.</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Step 5: Mapping Window Disambiguation -->
                        <div class="bg-orange-50 border border-orange-200 rounded-xl p-3 mt-3">
                            <div class="flex items-start">
                                <i class="fas fa-crosshairs text-orange-500 mr-2 mt-0.5"></i>
                                <div>
                                    <p class="text-xs text-orange-800 font-medium mb-1">Step 5: Recall Mapping Window Disambiguation</p>
                                    <p class="text-xs text-orange-700 mb-2">Now we use mapping window as positional context to select the best match among semantically similar candidates. When several candidates pass the semantic filter, recall mapping windows enforce chronological coherence—aligning repeated start events with start events and end events with end events, even if an end event is marginally more similar to an earlier one.</p>
                                    <div class="math-container">
                                        <p class="text-xs">$d_i = \begin{cases} 0 & \text{if } \text{start} \leq i < \text{end} \\ \min(|\text{start} - i|, |i - (\text{end} - 1)|) & \text{otherwise} \end{cases}$</p>
                                        <p class="text-xs">$\text{selected\_idx} = \underset{i \in C}{\arg\min} \; d_i$</p>
                                    </div>
                                    <p class="text-xs text-orange-700 mt-2">Candidates inside the mapping window ($d_i = 0$) are preferred, followed by those closest to the window boundaries.</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Step 6: Best Match Selection with Tie-Breaking -->
                        <div class="bg-orange-50 border border-orange-200 rounded-xl p-3 mt-3">
                            <div class="flex items-start">
                                <i class="fas fa-trophy text-orange-500 mr-2 mt-0.5"></i>
                                <div>
                                    <p class="text-xs text-orange-800 font-medium mb-1">Step 6: Recall Best Match Selection with Similarity-Based Tie-Breaking</p>
                                    <p class="text-xs text-orange-700 mb-2">The optimal recall match is selected by prioritizing minimum distance, with similarity used as an intelligent tie-breaker when multiple candidates share the same distance.</p>
                                    <div class="math-container">
                                        <p class="text-xs">$d_{\text{min}} = \min(d_i \; \forall i \in C)$</p>
                                        <p class="text-xs">$C_{\text{tied}} = \{i \in C \mid d_i = d_{\text{min}}\}$</p>
                                        <p class="text-xs">$\text{best\_match} = \begin{cases} 
                                        \text{unique } i \text{ where } d_i = d_{\text{min}} & \text{if } |C_{\text{tied}}| = 1 \\
                                        \underset{i \in C_{\text{tied}}}{\arg\max} \; \text{similarity}_i & \text{if } |C_{\text{tied}}| > 1
                                        \end{cases}$</p>
                                    </div>
                                    <p class="text-xs text-orange-700 mt-2">This ensures that when distances are equal, the candidate with the highest semantic similarity is selected, improving match quality while maintaining structural coherence.</p>
                                </div>
                            </div>
                        </div>

                        <!-- Step 7: Precision Process -->
                        <div class="bg-green-50 border border-green-200 rounded-xl p-3 mt-3">
                            <div class="flex items-start">
                                <i class="fas fa-redo text-green-500 mr-2 mt-0.5"></i>
                                <div>
                                    <p class="text-xs text-green-800 font-medium mb-1">Step 7: Precision Best Matches</p>
                                    <p class="text-xs text-green-700 mb-2">The entire process (Steps 2-6) is repeated for precision evaluation, with precision mapping windows used instead of recall mapping windows for disambiguation in Step 5.</p>
                                    <p class="text-xs text-green-700">This produces precision best matches that map generated chunks to reference chunks, complementing the recall best matches that map reference chunks to generated chunks.</p>
                                </div>
                            </div>
                        </div>

                        <!-- Algorithm Conclusion -->
                        <div class="bg-blue-50 border border-blue-200 rounded-xl p-3 mt-3">
                            <div class="flex items-start">
                                <i class="fas fa-play-circle text-blue-500 mr-2 mt-0.5"></i>
                                <div>
                                    <p class="text-xs text-blue-800 font-medium mb-1">🎯 Interactive Demo</p>
                                    <p class="text-xs text-blue-700 mb-2">Now that you understand how the best matching algorithm works for both precision and recall evaluation, use the interactive demo below to see how semantic ambiguity and collision problems are resolved in real-time.</p>
                                    <p class="text-xs text-blue-700">Experiment with different similarity matrices and parameter settings to observe how the algorithm adapts to find optimal one-to-one chunk alignments.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </details>
        </div>

        <!-- App Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="lg:col-span-2 space-y-8">
                <!-- Matrix Visualization -->
                <div id="tour-step-viz" class="demo-card interactive-card rounded-xl p-6">
                    <div class="text-center mb-6">
                        <div class="inline-flex items-center bg-teal-100 text-teal-800 px-3 py-1 rounded-full text-xs font-semibold mb-2"><i class="fas fa-chart-line mr-1"></i>SIMILARITY MATRIX</div>
                        <h2 class="text-xl font-bold text-slate-800">Interactive Best Matching Visualization</h2>
                        <p class="text-sm text-slate-500 mt-1">Click any cell to edit similarity values • Observe real-time algorithm behavior</p>
                    </div>
                    <div class="relative w-full max-w-4xl mx-auto pt-4 pb-12 pl-12 pr-2">
                        <div class="absolute top-1/2 -left-16 -translate-y-1/2 -rotate-90 font-semibold text-sm text-slate-600 whitespace-nowrap">Reference Chunks</div>
                        <div class="absolute -bottom-2 left-1/2 -translate-x-1/2 font-semibold text-sm text-slate-600">Generated Chunks</div>
                        <div class="relative w-full aspect-square">
                            <div id="chartGrid" class="absolute inset-0 bg-white rounded-lg chart-grid-background border border-slate-200">
                                <button id="contextVisualizationToggle" class="context-visualization-toggle" title="Show context window candidates">
                                    <i class="fas fa-eye"></i>
                                    <span>Context</span>
                                </button>
                                <div id="idealMappingContainer"></div>
                                <div id="maxSimilarityHighlightContainer"></div>
                                <div id="bestMatchHighlightContainer"></div>
                                <div id="contextCandidateHighlightContainer"></div>
                                <div id="similarityValueContainer"></div>
                                <div id="axisLabelContainerY"></div>
                                <div id="axisLabelContainerX"></div>
                            </div>
                        </div>
                    </div>
                    <div class="flex justify-center items-center gap-4 mt-4 pt-4 border-t border-slate-200/80 flex-wrap">
                        <div class="flex items-center gap-2"><div class="w-4 h-4 rounded border-2 border-teal-600 bg-teal-500/20"></div><span class="text-xs text-slate-600 font-medium">Mapping Window</span></div>
                        <div class="flex items-center gap-2"><div class="w-4 h-4 rounded border-2 border-amber-500 bg-amber-500/30"></div><span class="text-xs text-slate-600 font-medium">Best Match</span></div>
                        <div class="flex items-center gap-2"><div class="w-4 h-4 rounded border-2 border-purple-500 bg-purple-500/20"></div><span class="text-xs text-slate-600 font-medium">Alternative Match</span></div>
                        <div class="flex items-center gap-2"><div class="w-4 h-4 rounded border border-purple-500 border-dashed bg-purple-500/10"></div><span class="text-xs text-slate-600 font-medium">Context Candidates (toggleable)</span></div>
                    </div>
                </div>
            </div>

            <!-- Controls Panel -->
            <div class="lg:col-span-1">
                <div class="sticky top-6 flex flex-col gap-6">
                    <div id="tour-step-controls" class="demo-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-slate-800 mb-4 flex items-center"><i class="fas fa-th text-teal-600 mr-2"></i>Grid Size</h3>
                        <div class="space-y-4">
                            <div><label for="refLenInput" class="block text-sm font-medium mb-2">Reference Chunks (Y-Axis)</label><input type="number" id="refLenInput" min="1" max="15" value="9" class="w-full p-3 neumorphic-input"></div>
                            <div><label for="genLenInput" class="block text-sm font-medium mb-2">Generated Chunks (X-Axis)</label><input type="number" id="genLenInput" min="1" max="15" value="9" class="w-full p-3 neumorphic-input"></div>
                        </div>
                    </div>
                    <div id="tour-step-scenarios" class="demo-card interactive-card rounded-xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold text-slate-800 flex items-center"><i class="fas fa-magic text-purple-600 mr-2"></i>Test Scenarios</h3>
                            <button id="testing-guide-btn" class="bg-teal-500 hover:bg-teal-600 text-white px-3 py-1.5 rounded-lg text-xs font-medium transition-transform transform hover:scale-105">
                                <i class="fas fa-clipboard-check mr-1"></i>Testing Guide
                            </button>
                        </div>
                        <div class="space-y-3">
                            <button class="neumorphic-btn w-full py-3 text-sm" onclick="setCollisionScenario()"><i class="fas fa-sitemap mr-2"></i>Semantic Collisions</button>
                            <button class="neumorphic-btn w-full py-3 text-sm" onclick="setAmbiguityScenario()"><i class="fas fa-question-circle mr-2"></i>Semantic Ambiguity</button>
                            <button class="neumorphic-btn w-full py-3 text-sm" onclick="setRandomScenario()"><i class="fas fa-random mr-2"></i>Random Similarities</button>
                        </div>
                    </div>
                    <div id="tour-step-params" class="formula-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-purple-800 mb-3 flex items-center"><i class="fas fa-cogs text-purple-600 mr-2"></i>Algorithm Controls</h3>
                        <div class="space-y-4">
                            <div><label for="contextCutoffInput" class="block text-sm font-medium mb-2">Context Cutoff<i class="fas fa-info-circle text-purple-500 ml-1" title="Minimum similarity to apply context window"></i></label><input type="number" id="contextCutoffInput" min="0" max="1" step="0.01" value="0.6" class="w-full p-3 neumorphic-input"><p class="text-xs text-purple-600 mt-1">Below this, no context window is applied</p></div>
                            <div><label for="contextWindowCtrlInput" class="block text-sm font-medium mb-2">Context Window Control<i class="fas fa-info-circle text-purple-500 ml-1" title="Controls the width of the adaptive context window"></i></label><input type="number" id="contextWindowCtrlInput" min="0.1" max="10" step="0.1" value="4.0" class="w-full p-3 neumorphic-input"><p class="text-xs text-purple-600 mt-1">Higher values = narrower context windows</p></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
                </main>
            </article>
        </div>
    </div>

    <!-- Testing Modal -->
    <div id="testing-modal" class="testing-modal">
        <div class="testing-modal-content">
            <div class="testing-modal-header">
                <h2 class="text-xl font-bold text-slate-800 flex items-center">
                    <i class="fas fa-clipboard-check mr-2 text-teal-600"></i>
                    Testing Guide
                </h2>
                <button id="testing-modal-close" class="testing-modal-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="testing-content">
                <!-- Getting Started -->
                <div class="test-category">
                    <h3><i class="fas fa-play-circle"></i>Getting Started</h3>
                    <div class="test-item">
                        <h4>Understanding the Visualization</h4>
                        <p>This guide will help you understand how the best matching algorithm works by observing key patterns in the similarity matrix.</p>
                        <ul class="test-checklist">
                            <li>Orange cells show the best match selected by the algorithm</li>
                            <li>Purple cells show alternative high-similarity matches (when different from best match)</li>
                            <li>Teal rectangles show mapping windows that constrain valid matches</li>
                            <li>Click any cell to edit similarity values and see algorithm behavior change</li>
                        </ul>
                    </div>
                </div>

                <!-- Semantic Collisions -->
                <div class="test-category">
                    <h3><i class="fas fa-sitemap"></i>Semantic Collisions Testing</h3>
                    <div class="test-item">
                        <h4>What to Notice</h4>
                        <p>When you click "Semantic Collisions", the grid is reset with different values where multiple chunks have identical high similarities. Each click generates a new random collision scenario.</p>
                        <ul class="test-checklist">
                            <li>Multiple cells in columns will have the same high similarity value</li>
                            <li>Click the "Context" button (top-left of the similarity matrix) to see all candidates that have same similarity values</li>
                            <li>The algorithm picks the match closest to the mapping window (teal rectangle)</li>
                            <li>Even when similarities are identical, mapping windows break ties</li>
                            <li>This demonstrates how narrative structure guides optimal selection</li>
                        </ul>
                        <p class="text-sm text-slate-600 mt-2 italic">Click "Semantic Collisions" multiple times to see different collision patterns - each click resets the grid with new random values simulating various semantic collision scenarios.</p>
                    </div>
                </div>

                <!-- Semantic Ambiguity -->
                <div class="test-category">
                    <h3><i class="fas fa-question-circle"></i>Semantic Ambiguity Testing</h3>
                    <div class="test-item">
                        <h4>What to Notice</h4>
                        <p>When you click "Semantic Ambiguity", the grid is reset with different values where the algorithm uses adaptive context windows to resolve unclear matches. Each click generates a new random ambiguity scenario.</p>
                        <ul class="test-checklist">
                            <li>Purple cells show where context windows reject the highest similarity</li>
                            <li>Context window values are displayed as "CW: 0.xxx" on purple cells</li>
                            <li>Click the "Context" button (top-left of the similarity matrix) to see all context window candidates</li>
                            <li>Dashed purple borders highlight all similarities that met the context threshold</li>
                            <li>The context window size depends on Context Cutoff and Context Control settings</li>
                            <li>Algorithm chooses mapping-window-closest match among context-filtered candidates</li>
                        </ul>
                        <p class="text-sm text-slate-600 mt-2 italic">Click "Semantic Ambiguity" multiple times to see different ambiguity patterns - each click resets the grid with new random values simulating various semantic ambiguity scenarios. Observe how context windows adapt based on similarity strength and your parameter settings.</p>
                    </div>
                </div>

                <!-- Manual Exploration -->
                <div class="test-category">
                    <h3><i class="fas fa-hand-pointer"></i>Manual Cell Editing</h3>
                    <div class="test-item">
                        <h4>Interactive Testing</h4>
                        <p>Click any cell to manually edit similarity values and simulate various matching scenarios.</p>
                        <ul class="test-checklist">
                            <li>Create your own collision scenarios by setting multiple cells to the same value</li>
                            <li>Test ambiguity by creating subtle differences between high-similarity cells</li>
                            <li>Observe how the algorithm responds to your custom similarity patterns</li>
                            <li>Watch real-time updates as orange/purple highlights change with your edits</li>
                        </ul>
                    </div>
                </div>

                <!-- Parameter Control -->
                <div class="test-category">
                    <h3><i class="fas fa-cogs"></i>Algorithm Parameter Testing</h3>
                    <div class="test-item">
                        <h4>Context Cutoff Experiments</h4>
                        <p>Adjust the Context Cutoff parameter to see how it affects algorithm behavior.</p>
                        <ul class="test-checklist">
                            <li>Set Context Cutoff to 1.0 to completely disable the best matching algorithm</li>
                            <li>With cutoff = 1.0, only the highest similarity cells will be selected (naive approach)</li>
                            <li>Lower cutoff values (like 0.3) allow more aggressive context filtering</li>
                            <li>Higher cutoff values (like 0.8) make context windows more restrictive</li>
                        </ul>
                    </div>
                    <div class="test-item">
                        <h4>Context Window Control</h4>
                        <p>Experiment with the Context Window Control parameter to adjust context window width.</p>
                        <ul class="test-checklist">
                            <li>Higher values (like 8.0) create narrower context windows</li>
                            <li>Lower values (like 1.0) create wider context windows</li>
                            <li>Watch how context window values change on purple cells</li>
                            <li>Observe how this affects which candidates survive filtering</li>
                        </ul>
                    </div>
                </div>

                <!-- Key Insights -->
                <div class="test-category">
                    <h3><i class="fas fa-lightbulb"></i>Key Insights</h3>
                    <div class="test-item">
                        <h4>What You Should Understand</h4>
                        <p>After exploring different scenarios and parameters, you should understand these core concepts:</p>
                        <ul class="test-checklist">
                            <li>Best matching solves problems that naive maximum similarity cannot handle</li>
                            <li>Context windows adapt dynamically based on similarity strength</li>
                            <li>Mapping windows provide narrative-aware tie-breaking between candidates</li>
                            <li>The dual mechanism (context + mapping windows) ensures optimal alignments</li>
                            <li>Parameter tuning allows fine control over algorithm aggressiveness</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const chartGrid = document.getElementById('chartGrid');
        const idealMappingContainer = document.getElementById('idealMappingContainer');
        const bestMatchHighlightContainer = document.getElementById('bestMatchHighlightContainer');
        const maxSimilarityHighlightContainer = document.getElementById('maxSimilarityHighlightContainer');
        const contextCandidateHighlightContainer = document.getElementById('contextCandidateHighlightContainer');
        const similarityValueContainer = document.getElementById('similarityValueContainer');
        const axisLabelContainerX = document.getElementById('axisLabelContainerX');
        const axisLabelContainerY = document.getElementById('axisLabelContainerY');
        const refLenInput = document.getElementById('refLenInput');
        const genLenInput = document.getElementById('genLenInput');
        const contextCutoffInput = document.getElementById('contextCutoffInput');
        const contextWindowCtrlInput = document.getElementById('contextWindowCtrlInput');
        const appBackground = document.getElementById('app-background');
        const testingGuideBtn = document.getElementById('testing-guide-btn');
        const testingModal = document.getElementById('testing-modal');
        const testingModalClose = document.getElementById('testing-modal-close');
        const contextVisualizationToggle = document.getElementById('contextVisualizationToggle');

        // --- State Variables ---
        let numUnitsY = parseInt(refLenInput.value, 10);
        let numUnitsX = parseInt(genLenInput.value, 10);
        let contextCutoffValue = parseFloat(contextCutoffInput.value);
        let contextWindowCtrl = parseFloat(contextWindowCtrlInput.value);
        let similarityMatrix = [];
        let currentPrecisionWindows = [];
        let showContextCandidates = false;

        // --- Tour Manager ---
        const tourManager = {
            isActive: false,
            currentStep: 0,
            overlay: document.getElementById('tour-overlay'),
            steps: [
                { selector: '#tour-step-intro', text: 'Welcome to Best Matching! This demo shows how to find optimal chunk alignments when multiple candidates have similar scores. Visit the Mapping Window demo first to understand alignment constraints.', position: 'bottom' },
                { selector: '#tour-step-math', text: 'Click to expand the algorithm breakdown. This shows the 7-step mathematical theory behind best matching with context windows.', position: 'bottom' },
                { selector: '#tour-step-viz', text: 'This matrix shows similarity scores between chunks. Orange cells are final best matches, purple cells are rejected alternatives. Click any cell to edit values and watch the algorithm adapt.', position: 'top' },
                { selector: '#tour-step-controls', text: 'Adjust the grid size here to simulate different text lengths. Watch how mapping windows (teal rectangles) resize automatically as you change dimensions.', position: 'left' },
                { selector: '#tour-step-scenarios', text: 'Try these preset scenarios to explore different matching challenges. Each button demonstrates a specific problem the algorithm solves. Check the Testing Guide for detailed exploration strategies.', position: 'left' },
                { selector: '#tour-step-params', text: 'Control algorithm sensitivity with these parameters. Context Cutoff sets the minimum similarity for context windows, while Context Window Control adjusts window width. Experiment to see their effects.', position: 'left' }
            ],
            start: function() { 
                this.isActive = true; 
                this.currentStep = 0; 
                this.overlay.style.pointerEvents = 'auto'; 
                this.overlay.style.opacity = '1'; 
                this.addClickOutsideHandler();
                this.showStep(); 
            },
            next: function() { this.cleanupCurrentStep(); this.currentStep++; if (this.currentStep < this.steps.length) { setTimeout(() => this.showStep(), 400); } else { this.end(); } },
            showStep: function() {
                const step = this.steps[this.currentStep];
                const targetElement = document.querySelector(step.selector);
                if (!targetElement) { this.end(); return; }
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                setTimeout(() => {
                    targetElement.classList.add('tour-highlight');
                    const callout = document.createElement('div');
                    callout.id = 'tour-callout';
                    callout.innerHTML = `<p class="text-sm mb-4">${step.text}</p><div class="flex justify-end"><button onclick="tourManager.next()">Next &rarr;</button></div>`;
                    document.body.appendChild(callout);
                    const targetRect = targetElement.getBoundingClientRect();
                    const calloutRect = callout.getBoundingClientRect();
                    const margin = 15;
                    const scrollY = window.scrollY || document.documentElement.scrollTop;
                    const scrollX = window.scrollX || document.documentElement.scrollLeft;
                    let top, left;
                    switch (step.position) {
                        case 'bottom': top = targetRect.bottom + scrollY + margin; left = targetRect.left + scrollX + (targetRect.width / 2) - (calloutRect.width / 2); break;
                        case 'top': top = targetRect.top + scrollY - calloutRect.height - margin; left = targetRect.left + scrollX + (targetRect.width / 2) - (calloutRect.width / 2); break;
                        case 'left': top = targetRect.top + scrollY + (targetRect.height / 2) - (calloutRect.height / 2); left = targetRect.left + scrollX - calloutRect.width - margin; break;
                        case 'right': top = targetRect.top + scrollY + (targetRect.height / 2) - (calloutRect.height / 2); left = targetRect.right + scrollX + margin; break;
                        default: top = targetRect.bottom + scrollY + margin; left = targetRect.left + scrollX;
                    }
                    const viewportRight = scrollX + window.innerWidth;
                    const viewportBottom = scrollY + window.innerHeight;
                    if (left < scrollX + margin) left = scrollX + margin;
                    if (left + calloutRect.width > viewportRight - margin) left = viewportRight - calloutRect.width - margin;
                    if (top < scrollY + margin) top = scrollY + margin;
                    if (top + calloutRect.height > viewportBottom - margin) top = viewportBottom - calloutRect.height - margin;
                    callout.style.top = `${top}px`;
                    callout.style.left = `${left}px`;
                    requestAnimationFrame(() => { callout.classList.add('visible'); });
                }, 350);
            },
            cleanupCurrentStep: function() { const oldHighlight = document.querySelector('.tour-highlight'); if (oldHighlight) oldHighlight.classList.remove('tour-highlight'); const oldCallout = document.getElementById('tour-callout'); if (oldCallout) oldCallout.remove(); },
            end: function() { 
                this.cleanupCurrentStep(); 
                this.isActive = false; 
                this.overlay.style.opacity = '0'; 
                this.removeClickOutsideHandler();
                setTimeout(() => this.overlay.style.pointerEvents = 'none', 400); 
            },
            addClickOutsideHandler: function() {
                this.clickOutsideHandler = (e) => {
                    if (this.isActive) {
                        const callout = document.getElementById('tour-callout');
                        if (callout && !callout.contains(e.target)) {
                            this.end();
                        }
                    }
                };
                document.addEventListener('click', this.clickOutsideHandler);
            },
            removeClickOutsideHandler: function() {
                if (this.clickOutsideHandler) {
                    document.removeEventListener('click', this.clickOutsideHandler);
                    this.clickOutsideHandler = null;
                }
            }
        };

        // --- Scenario Preset Functions ---
        function setCollisionScenario() {
            for (let c = 0; c < numUnitsX; c++) {
                const baseValue = (Math.random() * 0.6 + 0.3);
                const indices = [];
                while (indices.length < 2) { const randomIdx = Math.floor(Math.random() * numUnitsY); if (!indices.includes(randomIdx)) indices.push(randomIdx); }
                for (let r = 0; r < numUnitsY; r++) { similarityMatrix[r][c] = indices.includes(r) ? parseFloat(baseValue.toFixed(2)) : parseFloat((Math.random() * 0.4).toFixed(2)); }
            }
            renderAll();
        }

        function setAmbiguityScenario() {
            for (let c = 0; c < numUnitsX; c++) {
                const baseValue = (Math.random() * 0.5 + 0.4);
                const indices = [];
                while (indices.length < 2) { const randomIdx = Math.floor(Math.random() * numUnitsY); if (!indices.includes(randomIdx)) indices.push(randomIdx); }
                for (let r = 0; r < numUnitsY; r++) {
                    if (indices.includes(r)) { const variation = indices[0] === r ? 0 : (Math.random() * 0.03); similarityMatrix[r][c] = parseFloat((baseValue - variation).toFixed(2)); } 
                    else { similarityMatrix[r][c] = parseFloat((Math.random() * 0.3).toFixed(2)); }
                }
            }
            renderAll();
        }

        function setRandomScenario() { initializeSimilarityMatrix(numUnitsY, numUnitsX); renderAll(); }

        // --- Testing Modal Manager ---
        const testingModalManager = {
            open: function() {
                testingModal.classList.add('visible');
                document.body.style.overflow = 'hidden';
            },
            close: function() {
                testingModal.classList.remove('visible');
                document.body.style.overflow = 'auto';
            },
            toggle: function() {
                if (testingModal.classList.contains('visible')) {
                    this.close();
                } else {
                    this.open();
                }
            }
        };

        // --- Core Logic ---
        function initializeSimilarityMatrix(rows, cols) {
            similarityMatrix = [];
            for (let r = 0; r < rows; r++) { const row = []; for (let c = 0; c < cols; c++) { row.push(parseFloat(Math.random().toFixed(2))); } similarityMatrix.push(row); }
        }

        function get_mapping_windows_js(refLen, genLen) {
            const isRefLonger = refLen >= genLen;
            const longerLen = isRefLonger ? refLen : genLen; const shorterLen = isRefLonger ? genLen : refLen;
            if (shorterLen === 0) return { precision_windows: [] };
            const slope = longerLen / shorterLen;
            const mappingWindowHeight = Math.ceil(slope);
            let direct_windows = [];
            for (let i = 0; i < shorterLen; i++) { const idx_point = i * slope; const start = Math.max(Math.floor(idx_point), 0); const end = Math.min(start + mappingWindowHeight, longerLen); direct_windows.push({ start: start, end: end }); }
            let precision_windows_for_gen_chunks;
            if (isRefLonger) { precision_windows_for_gen_chunks = direct_windows; } 
            else {
                precision_windows_for_gen_chunks = [];
                for (let genIdx = 0; genIdx < genLen; genIdx++) {
                    let mappedRefIndices = [];
                    direct_windows.forEach((ref_window_on_gen_axis, refIdx) => { if (genIdx >= ref_window_on_gen_axis.start && genIdx < ref_window_on_gen_axis.end) { mappedRefIndices.push(refIdx); } });
                    if (mappedRefIndices.length > 0) { precision_windows_for_gen_chunks.push({ start: Math.min(...mappedRefIndices), end: Math.max(...mappedRefIndices) + 1 }); } 
                    else { const proportionalRefPos = Math.floor((genIdx / genLen) * refLen); precision_windows_for_gen_chunks.push({ start: proportionalRefPos, end: Math.min(proportionalRefPos + 1, refLen) }); }
                }
            }
            return { precision_windows: precision_windows_for_gen_chunks };
        }

        function findBestMatchWithContextJS(similarityArray, mappingWindow, cutoff, ctrl) {
            let maxVal = -Infinity; let maxIdx = -1;
            if (!similarityArray || similarityArray.length === 0) return { bestMatchIndex: -1, maxSimilarityIndex: -1, maxSimilarityValue: -Infinity, contextWindowApplied: false, calculatedContextWindow: 0 };
            similarityArray.forEach((val, idx) => { if (val > maxVal) { maxVal = val; maxIdx = idx; } });
            if (maxIdx === -1) return { bestMatchIndex: -1, maxSimilarityIndex: -1, maxSimilarityValue: maxVal, contextWindowApplied: false, calculatedContextWindow: 0 };
            const contextRange = 1 - cutoff;
            const contextWindowApplied = maxVal > 0 && (contextRange - (1 - maxVal)) > 0;
            const contextValueDrop = contextWindowApplied ? ((contextRange - (1 - maxVal)) / maxVal) / ctrl : 0.0;
            const contextThreshold = maxVal - contextValueDrop;
            const calculatedCtxWindowForDisplay = contextValueDrop;
            const candidateIndices = []; const candidateValues = [];
            similarityArray.forEach((val, idx) => { if (val >= contextThreshold) { candidateIndices.push(idx); candidateValues.push(val); } });
            let bestMatchIndexToReturn = maxIdx;
            if (candidateIndices.length === 0) { bestMatchIndexToReturn = maxIdx; } 
            else if (candidateIndices.length === 1 || !mappingWindow) { bestMatchIndexToReturn = candidateIndices.length === 1 ? candidateIndices[0] : maxIdx; } 
            else {
                const { start, end } = mappingWindow; let distances = [];
                candidateIndices.forEach(candIdx => { const isInWin = candIdx >= start && candIdx < end; if (isInWin) { distances.push(0); } else { const leftDist = Math.max(start - candIdx, 0); const rightDist = Math.max(candIdx - (end - 1), 0); distances.push(Math.max(leftDist, rightDist)); } });
                let minDistance = Infinity; let highestSimilarityInMinDistanceGroup = -Infinity; bestMatchIndexToReturn = -1;
                for (let i = 0; i < candidateIndices.length; i++) {
                    const currentCandOriginalIndex = candidateIndices[i]; const currentCandSimilarity = candidateValues[i]; const currentDistance = distances[i];
                    if (currentDistance < minDistance) { minDistance = currentDistance; highestSimilarityInMinDistanceGroup = currentCandSimilarity; bestMatchIndexToReturn = currentCandOriginalIndex; } 
                    else if (currentDistance === minDistance) { if (currentCandSimilarity > highestSimilarityInMinDistanceGroup) { highestSimilarityInMinDistanceGroup = currentCandSimilarity; bestMatchIndexToReturn = currentCandOriginalIndex; } }
                }
            }
            return { bestMatchIndex: bestMatchIndexToReturn, maxSimilarityIndex: maxIdx, maxSimilarityValue: maxVal, contextWindowApplied: contextWindowApplied, calculatedContextWindow: calculatedCtxWindowForDisplay };
        }

        // --- Render Functions ---
        function renderGridLines(container, numX, numY) {
            container.querySelectorAll('.grid-line').forEach(e => e.remove());
            for (let i = 0; i <= numX; i++) {
                const line = document.createElement('div');
                line.className = 'grid-line';
                line.style.position = 'absolute';
                line.style.left = `${i / numX * 100}%`;
                line.style.top = '0';
                line.style.bottom = '0';
                line.style.borderLeft = '1px solid rgba(148, 163, 184, 0.3)';
                container.appendChild(line);
            }
            for (let i = 0; i <= numY; i++) {
                const line = document.createElement('div');
                line.className = 'grid-line';
                line.style.position = 'absolute';
                line.style.top = `${i / numY * 100}%`;
                line.style.left = '0';
                line.style.right = '0';
                line.style.borderBottom = '1px solid rgba(148, 163, 184, 0.3)';
                container.appendChild(line);
            }
        }

        function renderIdealMappingWindows() {
            if (!currentPrecisionWindows) return;
            
            // Apply element reuse strategy for smooth transitions
            const existingWindows = Array.from(idealMappingContainer.children);
            let windowIndex = 0;
            
            currentPrecisionWindows.forEach((window, gen_chunk_idx) => {
                if (gen_chunk_idx >= numUnitsX || !window) return;
                
                // Reuse existing window or create new one
                let idealWindowDiv = existingWindows[windowIndex];
                if (!idealWindowDiv) {
                    idealWindowDiv = document.createElement('div');
                    idealWindowDiv.classList.add('ideal-mapping-window');
                    idealMappingContainer.appendChild(idealWindowDiv);
                }
                
                // Update position and size - CSS transitions handle the animation
                idealWindowDiv.style.left = `calc(${gen_chunk_idx} * 100% / ${numUnitsX})`;
                idealWindowDiv.style.width = `calc(100% / ${numUnitsX})`;
                idealWindowDiv.style.bottom = `calc(${window.start} * 100% / ${numUnitsY})`;
                const windowHeight = Math.max(0, window.end - window.start);
                idealWindowDiv.style.height = `calc(${windowHeight} * 100% / ${numUnitsY})`;
                
                windowIndex++;
            });
            
            // Remove extra windows
            while (idealMappingContainer.children.length > windowIndex) {
                idealMappingContainer.lastChild.remove();
            }
        }

        function handleCellEdit(event, r_idx, c_idx) {
            const rawValue = event.target.value; let newValue = parseFloat(rawValue);
            if (!isNaN(newValue)) { newValue = Math.max(0, Math.min(1, newValue)); similarityMatrix[r_idx][c_idx] = parseFloat(newValue.toFixed(2)); event.target.value = similarityMatrix[r_idx][c_idx].toFixed(2); renderBestMatches(); renderMaxSimilarityHighlights(); } 
            else if (rawValue === "") { similarityMatrix[r_idx][c_idx] = 0; event.target.value = "0.00"; renderBestMatches(); renderMaxSimilarityHighlights(); } 
            else { event.target.value = similarityMatrix[r_idx][c_idx].toFixed(2); }
        }

        function renderSimilarityValues() {
            // For similarity values grid, clearing and rebuilding is more efficient
            // since grid dimensions and cell count change frequently
            similarityValueContainer.innerHTML = '';
            if (!similarityMatrix || similarityMatrix.length === 0) return;
            const cellWidth = `calc(100% / ${numUnitsX})`; const cellHeight = `calc(100% / ${numUnitsY})`;
            for (let r_idx = 0; r_idx < numUnitsY; r_idx++) {
                for (let c_idx = 0; c_idx < numUnitsX; c_idx++) {
                    const inputCell = document.createElement('input');
                    inputCell.type = 'number'; inputCell.min = '0'; inputCell.max = '1'; inputCell.step = '0.01';
                    inputCell.classList.add('similarity-input-cell');
                    inputCell.value = similarityMatrix[r_idx][c_idx].toFixed(2);
                    inputCell.addEventListener('change', (event) => handleCellEdit(event, r_idx, c_idx));
                    const cellContainer = document.createElement('div');
                    cellContainer.classList.add('similarity-value-cell-container');
                    cellContainer.style.width = cellWidth; cellContainer.style.height = cellHeight;
                    cellContainer.style.left = `calc(${c_idx} * 100% / ${numUnitsX})`;
                    cellContainer.style.bottom = `calc(${r_idx} * 100% / ${numUnitsY})`;
                    cellContainer.appendChild(inputCell);
                    similarityValueContainer.appendChild(cellContainer);
                }
            }
        }

        function renderBestMatches() {
            if (!similarityMatrix || similarityMatrix.length === 0 || !currentPrecisionWindows) return;
            
            // Apply element reuse strategy for smooth transitions
            const existingHighlights = Array.from(bestMatchHighlightContainer.children);
            let highlightIndex = 0;
            
            for (let c_idx = 0; c_idx < numUnitsX; c_idx++) {
                const columnSimilarity = similarityMatrix.map(row => row[c_idx]);
                const mappingWindow = currentPrecisionWindows[c_idx];
                if (!mappingWindow) continue;
                const matchInfo = findBestMatchWithContextJS(columnSimilarity, mappingWindow, contextCutoffValue, contextWindowCtrl);
                if (matchInfo.bestMatchIndex !== -1 && matchInfo.bestMatchIndex < numUnitsY) {
                    // Reuse existing highlight or create new one
                    let highlightCell = existingHighlights[highlightIndex];
                    if (!highlightCell) {
                        highlightCell = document.createElement('div');
                        highlightCell.classList.add('best-match-cell');
                        bestMatchHighlightContainer.appendChild(highlightCell);
                    }
                    
                    // Update position and size - CSS transitions handle the animation
                    highlightCell.style.width = `calc(100% / ${numUnitsX})`;
                    highlightCell.style.height = `calc(100% / ${numUnitsY})`;
                    highlightCell.style.left = `calc(${c_idx} * 100% / ${numUnitsX})`;
                    highlightCell.style.bottom = `calc(${matchInfo.bestMatchIndex} * 100% / ${numUnitsY})`;
                    highlightCell.style.opacity = '1';
                    
                    // Handle context window text
                    let contextText = highlightCell.querySelector('.context-window-text');
                    if (matchInfo.bestMatchIndex === matchInfo.maxSimilarityIndex) {
                        if (!contextText) {
                            contextText = document.createElement('span');
                            contextText.classList.add('context-window-text');
                            highlightCell.appendChild(contextText);
                        }
                        contextText.textContent = `CW: ${matchInfo.calculatedContextWindow.toFixed(3)}`;
                    } else {
                        if (contextText) {
                            contextText.remove();
                        }
                    }
                    
                    highlightIndex++;
                }
            }
            
            // Remove extra highlights
            while (bestMatchHighlightContainer.children.length > highlightIndex) {
                bestMatchHighlightContainer.lastChild.remove();
            }
        }

        function renderMaxSimilarityHighlights() {
            if (!similarityMatrix || similarityMatrix.length === 0 || !currentPrecisionWindows) return;
            
            // Apply element reuse strategy for smooth transitions
            const existingHighlights = Array.from(maxSimilarityHighlightContainer.children);
            let highlightIndex = 0;
            
            for (let c_idx = 0; c_idx < numUnitsX; c_idx++) {
                const columnSimilarity = similarityMatrix.map(row => row[c_idx]);
                const mappingWindow = currentPrecisionWindows[c_idx];
                if (!mappingWindow) continue;
                const matchInfo = findBestMatchWithContextJS(columnSimilarity, mappingWindow, contextCutoffValue, contextWindowCtrl);
                if (matchInfo.maxSimilarityIndex !== -1 && matchInfo.maxSimilarityIndex !== matchInfo.bestMatchIndex) {
                    // Reuse existing highlight or create new one
                    let highlightCell = existingHighlights[highlightIndex];
                    if (!highlightCell) {
                        highlightCell = document.createElement('div');
                        highlightCell.classList.add('max-similarity-cell-highlight');
                        
                        const contextText = document.createElement('span');
                        contextText.classList.add('context-window-text');
                        highlightCell.appendChild(contextText);
                        
                        maxSimilarityHighlightContainer.appendChild(highlightCell);
                    }
                    
                    // Update position and size - CSS transitions handle the animation
                    highlightCell.style.width = `calc(100% / ${numUnitsX})`;
                    highlightCell.style.height = `calc(100% / ${numUnitsY})`;
                    highlightCell.style.left = `calc(${c_idx} * 100% / ${numUnitsX})`;
                    highlightCell.style.bottom = `calc(${matchInfo.maxSimilarityIndex} * 100% / ${numUnitsY})`;
                    highlightCell.style.opacity = '1';
                    
                    // Update context text
                    const contextText = highlightCell.querySelector('.context-window-text');
                    contextText.textContent = `CW: ${matchInfo.calculatedContextWindow.toFixed(3)}`;
                    
                    highlightIndex++;
                }
            }
            
            // Remove extra highlights
            while (maxSimilarityHighlightContainer.children.length > highlightIndex) {
                maxSimilarityHighlightContainer.lastChild.remove();
            }
        }

        function renderContextCandidates() {
            if (!showContextCandidates || !similarityMatrix || similarityMatrix.length === 0 || !currentPrecisionWindows) {
                // Hide all existing candidates when not showing
                Array.from(contextCandidateHighlightContainer.children).forEach(child => {
                    child.style.opacity = '0';
                });
                return;
            }
            
            // Apply element reuse strategy for smooth transitions
            const existingHighlights = Array.from(contextCandidateHighlightContainer.children);
            let highlightIndex = 0;
            
            for (let c_idx = 0; c_idx < numUnitsX; c_idx++) {
                const columnSimilarity = similarityMatrix.map(row => row[c_idx]);
                const mappingWindow = currentPrecisionWindows[c_idx];
                if (!mappingWindow) continue;
                
                const matchInfo = findBestMatchWithContextJS(columnSimilarity, mappingWindow, contextCutoffValue, contextWindowCtrl);
                if (!matchInfo.contextWindowApplied) continue; // Only show for columns where context window is applied
                
                const contextThreshold = matchInfo.maxSimilarityValue - matchInfo.calculatedContextWindow;
                
                // Find all candidates that meet the context threshold
                columnSimilarity.forEach((similarity, r_idx) => {
                    if (similarity >= contextThreshold && r_idx !== matchInfo.bestMatchIndex && r_idx !== matchInfo.maxSimilarityIndex) {
                        // Reuse existing highlight or create new one
                        let candidateHighlight = existingHighlights[highlightIndex];
                        if (!candidateHighlight) {
                            candidateHighlight = document.createElement('div');
                            candidateHighlight.classList.add('context-candidate-highlight');
                            contextCandidateHighlightContainer.appendChild(candidateHighlight);
                        }
                        
                        // Update position and size - CSS transitions handle the animation
                        candidateHighlight.style.width = `calc(100% / ${numUnitsX})`;
                        candidateHighlight.style.height = `calc(100% / ${numUnitsY})`;
                        candidateHighlight.style.left = `calc(${c_idx} * 100% / ${numUnitsX})`;
                        candidateHighlight.style.bottom = `calc(${r_idx} * 100% / ${numUnitsY})`;
                        candidateHighlight.style.opacity = '1';
                        candidateHighlight.title = `Context candidate: ${similarity.toFixed(3)} (threshold: ${contextThreshold.toFixed(3)})`;
                        
                        highlightIndex++;
                    }
                });
            }
            
            // Hide extra highlights instead of removing them (for smoother transitions)
            for (let i = highlightIndex; i < existingHighlights.length; i++) {
                existingHighlights[i].style.opacity = '0';
            }
        }

        function toggleContextVisualization() {
            showContextCandidates = !showContextCandidates;
            
            const button = contextVisualizationToggle;
            const icon = button.querySelector('i');
            const text = button.querySelector('span');
            
            if (showContextCandidates) {
                button.classList.add('active');
                icon.className = 'fas fa-eye-slash';
                text.textContent = 'Hide';
                button.title = 'Hide context window candidates';
            } else {
                button.classList.remove('active');
                icon.className = 'fas fa-eye';
                text.textContent = 'Context';
                button.title = 'Show context window candidates';
            }
            
            renderContextCandidates();
        }

        function renderAxisLabels() {
            // Clear and rebuild axis labels (they change frequently with different configurations)
            // For axis labels, clearing is more efficient than complex reuse logic
            axisLabelContainerX.innerHTML = ''; 
            axisLabelContainerY.innerHTML = '';
            const maxGridIndexX = numUnitsX - 1; const maxGridIndexY = numUnitsY - 1;
            const yStep = Math.max(1, Math.floor(numUnitsY / 10)) || 1;
            const xStep = Math.max(1, Math.floor(numUnitsX / 10)) || 1;
            if (numUnitsY > 0) {
                 for (let i = 0; i <= maxGridIndexY; i += yStep) { const tL = document.createElement('div'); tL.classList.add('axis-label'); tL.textContent = i; tL.style.left = '-1rem'; tL.style.top = `calc(100% - (${i}*100%/${numUnitsY}) - (50%/${numUnitsY}))`; tL.style.transform = 'translateY(-50%) translateX(-100%)'; axisLabelContainerY.appendChild(tL); }
                 if (maxGridIndexY > 0 && (maxGridIndexY % yStep !== 0)) { const lTY = document.createElement('div'); lTY.classList.add('axis-label'); lTY.textContent = maxGridIndexY; lTY.style.left = '-1rem'; lTY.style.top = `calc(100% - (${maxGridIndexY}*100%/${numUnitsY}) - (50%/${numUnitsY}))`; lTY.style.transform = 'translateY(-50%) translateX(-100%)'; axisLabelContainerY.appendChild(lTY); }
            }
            if (numUnitsX > 0) {
                for (let i = 0; i <= maxGridIndexX; i += xStep) { const tL = document.createElement('div'); tL.classList.add('axis-label'); tL.textContent = i; tL.style.bottom = '-1.5rem'; tL.style.left = `calc(${i}*100%/${numUnitsX} + 50%/${numUnitsX})`; tL.style.transform = 'translateX(-50%)'; axisLabelContainerX.appendChild(tL); }
                if (maxGridIndexX > 0 && (maxGridIndexX % xStep !== 0)) { const lTX = document.createElement('div'); lTX.classList.add('axis-label'); lTX.textContent = maxGridIndexX; lTX.style.bottom = '-1.5rem'; lTX.style.left = `calc(${maxGridIndexX}*100%/${numUnitsX} + 50%/${numUnitsX})`; lTX.style.transform = 'translateX(-50%)'; axisLabelContainerX.appendChild(lTX); }
            }
        }

        // --- Main Render Orchestrator ---
        function renderAll() {
            renderSimilarityValues();
            renderBestMatches();
            renderMaxSimilarityHighlights();
            renderContextCandidates();
        }

        function initializeStateAndRender(isResize = false) {
            numUnitsY = parseInt(refLenInput.value, 10) || 1;
            numUnitsX = parseInt(genLenInput.value, 10) || 1;
            contextCutoffValue = parseFloat(contextCutoffInput.value) || 0.6;
            contextWindowCtrl = parseFloat(contextWindowCtrlInput.value) || 4.0;
            refLenInput.value = numUnitsY; genLenInput.value = numUnitsX;
            contextCutoffInput.value = contextCutoffValue; contextWindowCtrlInput.value = contextWindowCtrl;

            const dimensionsChanged = similarityMatrix.length !== numUnitsY || (similarityMatrix[0] && similarityMatrix[0].length !== numUnitsX);
            if (!isResize && (dimensionsChanged || similarityMatrix.length === 0)) { initializeSimilarityMatrix(numUnitsY, numUnitsX); } 
            else if (isResize && dimensionsChanged) { initializeSimilarityMatrix(numUnitsY, numUnitsX); }

            const windows = get_mapping_windows_js(numUnitsY, numUnitsX);
            currentPrecisionWindows = windows.precision_windows;
            renderGridLines(chartGrid, numUnitsX, numUnitsY);
            renderSimilarityValues();
            renderIdealMappingWindows();
            renderBestMatches();
            renderMaxSimilarityHighlights();
            renderAxisLabels();
        }

        // --- Initial Load & Event Listeners ---
        window.addEventListener('load', () => {
            document.getElementById('start-tour-btn').addEventListener('click', () => tourManager.start());
            refLenInput.addEventListener('change', () => initializeStateAndRender(false));
            genLenInput.addEventListener('change', () => initializeStateAndRender(false));
            contextCutoffInput.addEventListener('change', () => { contextCutoffValue = parseFloat(contextCutoffInput.value) || 0.6; contextCutoffInput.value = contextCutoffValue; renderBestMatches(); renderMaxSimilarityHighlights(); renderContextCandidates(); });
            contextWindowCtrlInput.addEventListener('change', () => { contextWindowCtrl = parseFloat(contextWindowCtrlInput.value) || 4.0; contextWindowCtrlInput.value = contextWindowCtrl; renderBestMatches(); renderMaxSimilarityHighlights(); renderContextCandidates(); });
            contextVisualizationToggle.addEventListener('click', toggleContextVisualization);
            window.addEventListener('resize', () => initializeStateAndRender(true));
            
            // Testing modal event listeners
            testingGuideBtn.addEventListener('click', () => testingModalManager.open());
            testingModalClose.addEventListener('click', () => testingModalManager.close());
            testingModal.addEventListener('click', (e) => {
                if (e.target === testingModal) {
                    testingModalManager.close();
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && testingModal.classList.contains('visible')) {
                    testingModalManager.close();
                }
                if (e.key === 't' && e.ctrlKey) {
                    e.preventDefault();
                    testingModalManager.toggle();
                }
            });
            
            // Set a default background on load
            if(appBackground) { appBackground.style.background = `linear-gradient(135deg, hsl(170, 20%, 90%) 0%, hsl(190, 30%, 95%) 100%)`; }
            initializeStateAndRender(false);
        });
    </script>
</body>
</html>
